#!/usr/bin/perl -w
#
###############################################################################
#
# File: fwsnort
#
# Purpose: To translate snort rules into equivalent iptables rules.
#          fwsnort is based on the original snort2iptables shell script
#          written by William Stearns.
#
# Author: Michael B. Rash <mbr@cipherdyne.com>
#
# Copyright (C) 2003 Michael B. Rash (mbr@cipherdyne.com)
#
# License (GNU Public License):
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
#    USA
#
# Snort Rule Options:
#
#   msg:           Prints a message in alerts and packet logs.
#   logto:         Log the packet to a user specified filename instead of the
#                  standard output file.
#   ttl:           Test the IP header's TTL field value.
#   tos:           Test the IP header's TOS field value.
#   id:            Test the IP header's fragment ID field for a specific
#                  value.
#   ipoption:      Watch the IP option fields for specific codes.
#   fragbits:      Test the fragmentation bits of the IP header.
#   dsize:         Test the packet's payload size against a value.
#   flags          Test the TCP flags for certain values.
#   seq:           Test the TCP sequence number field for a specific value.
#   ack:           Test the TCP acknowledgement field for a specific value.
#   itype:         Test the ICMP type field against a specific value.
#   icode:         Test the ICMP code field against a specific value.
#   icmp_id:       Test the ICMP ECHO ID field against a specific value.
#   icmp_seq:      Test the ICMP ECHO sequence number against a specific
#                  value.
#   content:       Search for a pattern in the packet's payload.
#   content-list:  Search for a set of patterns in the packet's payload.
#   offset:        Modifier for the content option, sets the offset to begin
#                  attempting a pattern match.
#   depth:         Modifier for the content option, sets the maximum search
#                  depth for a pattern match attempt.
#   nocase:        Match the preceding content string with case insensitivity.
#   session        Dumps the application layer information for a given
#                  session.
#   rpc:           Watch RPC services for specific application/procedure
#                  calls.
#   resp:          Active response (knock down connections, etc).
#   react:         Active response (block web sites).
#   reference:     External attack reference ids.
#   sid:           snort rule id.
#   rev:           Rule revision number.
#   classtype:     Rule classification identifier.
#   priority:      Rule severity identifier.
#   uricontent:    Search for a pattern in the URI portion of a packet
#   tag:           Advanced logging actions for rules.
#   ip_proto:      IP header's protocol value.
#   sameip:        Determines if source ip equals the destination ip.
#   stateless:     Valid regardless of stream state.
#   regex:         Wildcard pattern matching.
#
############################################################################
#
# $Id$
#

use IPTables::Parse;
use Net::IPv4Addr qw(:all);
use Tie::IxHash;
use File::Copy;
use Sys::Hostname;
use Getopt::Long;
use strict;

#======================== config ========================
my $fwsnort_dir = '/etc/fwsnort';
my $rules_dir   = "${fwsnort_dir}/snort_rules";
my $logdir      = "${fwsnort_dir}/log";
my $scripts_dir = "${fwsnort_dir}/fwscripts";
my $archive_dir = "${fwsnort_dir}/archive";

### config file
my $fwsnort_conf = "${fwsnort_dir}/fwsnort.conf";

### log and error files
my $logfile    = "${logdir}/fwsnort.log";
my $parse_errs = "${logdir}/parse_errs.log";

### iptables script
my $fwscript = "${scripts_dir}/fw_ruleset.sh";
#===================== end config =======================

### version number
my $version = '0.1';

### supported variables in snort signatures
my %snort_vars = (
    'EXTERNAL_NET'    => '',
    'HOME_NET'        => '',
    'HTTP_SERVERS'    => '',
    'SMTP_SERVERS'    => '',
    'DNS_SERVERS'     => '',
    'HTTP_PORTS'      => '',
    'TELNET_SERVERS'  => '',
    'AIM_SERVERS'     => '',
    'SQL_SERVERS'     => '',
    'SHELLCODE_PORTS' => '',
    'ORACLE_PORTS'    => ''
);

my %logprefix;
tie %logprefix, 'Tie::IxHash';  ### need to maintain ordering

%logprefix = (
    ### snort options that can be put into iptables
    ### ruleset, but only in log messages with --log-prefix
    'msg'       => 'msg:\s*\"(.*?)\"\s*;',
    'classtype' => '[\s;]classtype:\s*(.*?)\s*;',
    'sid'       => '[\s;]sid:\s*(\d+)\s*;',
    'reference' => '[\s;]reference:\s*(.*?)\s*;',
);

my %iptables_opts = (
    'uricontent' => '-m string',
    'content'    => '-m string',
    'flags'      => '--tcp-flags',
    'itype'      => '--icmp-type',
    'ttl'        => '--ttl',
    'tos'        => '--tos',
    'seq'        => '--log-tcp-sequence',
    'src'        => '-s',
    'src_p'      => '--sport',
    'dst'        => '-d',
    'dst_p'      => '--dport',
    'proto'      => '-p'
);

my %snort_opts = (
    ### snort options that we can directly filter on
    ### in iptables rulesets (snort options are separate
    ### from the snort "header" which include protocol,
    ### source, destination, etc.)
    'filter' => {
        'uricontent' => '[\s;]uricontent:\s*\"(.*?)\"\s*;',
        'content' => '[\s;]content:\s*\"(.*?)\"\s*;',
        'flags'   => '[\s;]flags:\s*(.*?)\s*;',
        'itype'   => '[\s;]itype:\s*(\d+)\s*;',
        'ttl'     => '[\s;]ttl:\s*(\d+)\s*;',
        'tos'     => '[\s;]tos:\s*(\d+)\s*;'
    },

    ### snort options which are logged within iptables
    ### logging statements (so we can detect these values
    ### but just not filter them directly)
    'log_only' => {
        'id'       => '[\s;]id:\s*(\d+)\s*;',
        'seq'      => '[\s;]seq:\s*(\d+)\s*;',
        'icmp_seq' => '[\s;]icmp_seq:\s*(\d+)\s*;',
        'icmp_id'  => '[\s;]icmp_id:\s*(\d+)\s*;',
        'icode'    => '[\s;]icode:\s*(\d+)\s*;'
    },

    ### snort options that can be put into iptables
    ### ruleset, but only in log messages with --log-prefix
    'logprefix' => \%logprefix,

    ### snort options that cannot be included directly
    ### within iptables filter statements (yet :)
    'unsupported' => {
        'offset'       => '[\s;]offset:\s*\d+\s*;',
        'depth'        => '[\s;]depth:\s*\d+\s*;',
        'dsize'        => '[\s;]dsize:\s*\S+\s*;',
        'seq'          => '[\s;]seq:\s*\d+\s*;',
        'ack'          => '[\s;]ack:\s*\d+\s*;',
        'fragbits'     => '[\s;]fragbits:\s*\S+\s*;',
        'content-list' => '[\s;]content\-list:\s*\".*?\"\s*;',
        'ipopts'       => '[\s;]ipopts:\s*.*?\s*;',
        'rpc'          => '[\s;]rpc:\s*\S+\s*;',
    },

    ### snort options that fwsnort will ignore
    'ignore' => {
        'rev'       => '[\s;]rev:\s*(\d+)\s*;'
    }
);

### variables that are supported by the fwsnort config
my %conf_supported_vars = ();

### port config (see any snort.conf file)
my @http_ports      = ();
my @shellcode_ports = ();
my @oracle_ports    = ();

### interface config
my %intf_net  = ();  ### corresponds to $EXTERNAL_NET and $HOME_NET
my %intf_type = ();

### server config
my @http_servers   = ();
my @smtp_servers   = ();
my @dns_servers    = ();
my @sql_servers    = ();
my @telnet_servers = ();
my @aim_servers    = ();

my %snort_sigs;

### For each internal interface fwsnort will create two associated iptables
### chains.  For example, suppose eth0 is the external interface and
### eth1 is the internal interface:
###   jump int: eth0   dst: internal network  (src doesn't matter)
###   jump int: eth1   src: internal network  (dst doesn't matter)
my %snort_chains;

### config and commands hashes (constructed by readconf())
my %config;
my %cmds;

### establish some default behavior
my $fw_apply   = 0;
my $fw_log     = 0;
my $fw_drop    = 0;
my $fw_reject  = 0;
my $help       = 0;
my $stdout     = 0;
my $debug      = 0;
my $verbose    = 0;
my $snort_sid  = 0;
my $dump_conf  = 0;
my $rules_type = '';

&usage(1) unless (GetOptions(
    'fw-apply'      => \$fw_apply,   # apply the generated ruleset
    'fw-log'        => \$fw_log,
    'fw-drop'       => \$fw_drop,
    'fw-reject'     => \$fw_reject,
    'snort-sid=i'   => \$snort_sid,  # Parse only this particular snort rule
    'type=s'        => \$rules_type, # process this type of snort rule
    'logfile=s'     => \$logfile,
    'stdout'        => \$stdout,     # print the fw ruleset on STDOUT
    'verbose'       => \$verbose,
    'debug'         => \$debug,
    'dump-conf'     => \$dump_conf,  # display config variables
    'config=s'      => \$fwsnort_conf, # manually specify the config file
    'help'          => \$help
));

&usage(0) if $help;

### make sure some directories exist, etc.
&setup();

### read in configuration info from the config file
&readconf();

### make sure the commands are where the
### config file says they are
&chk_commands();

### make sure the config is correct
&validateconf();

### display the config on STDOUT
&dump_conf() if $dump_conf;

### make sure the specified <type>.rules file exists
### if --type was used
&check_type() if $rules_type;

### parse snort rules (signatures)
print "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=",
    "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n",
    sprintf("%-30s%-10s%-10s%-10s%-10s", '    File', 'Filter',
        'Log-only', 'Failed', 'Total'), "\n\n";
&parse_snort_rules();
print "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=",
    "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n";

exit 0;
### write the equivalent iptables ruleset out to disk
&write_iptables();

exit 0;
#===================== end main ======================
sub parse_snort_rules() {
    opendir D, $rules_dir or die " ** Could not open $rules_dir";
    my @rfiles = readdir D;
    closedir D;
    shift @rfiles; shift @rfiles;

    my $abs_num = 0;
    my $sabs_num = 0;
    FILE: for my $rfile (@rfiles) {
        next FILE unless $rfile =~ /\.rules$/;
        if ($rules_type) {
            next FILE unless $rfile =~ /${rules_type}\.rules$/;
        }
        my ($type) = ($rfile =~ /(\w+)\.rules/);
        printf("%-30s", " .. $rfile");
        open R, "< ${rules_dir}/${rfile}" or die " ** Could not " .
            "open: ${rules_type}/${rfile}";
        my @lines = <R>;
        close R;
        my $line_num    = 0;
        my $rule_num    = 0;
        my $parsed_ctr  = 0;
        my $logonly_ctr = 0;
        my $unsup_ctr   = 0;
        RULE: for my $line (@lines) {
            $line_num++;
            next RULE unless $line =~ /^alert/;
            $rule_num++;  ### keep track of the abs num of rules
            my $rule_hdr;
            my $rule_options;
            $sabs_num++;
            if ($line =~ m|^(.*)\s+\((.*)\)|) {
                $rule_hdr     = $1;
                $rule_options = $2;
            } else {  ### don't know what type of snort rule it is
                next RULE;
            }
            my $hdr_href = &parse_rule_hdr($rule_hdr);
            unless ($hdr_href) {
                print " ** Unrecognized rule header: \"$rule_hdr\" at ",
                    "line: $line_num.  Skipping rule.\n";
                $unsup_ctr++;
                next RULE;
            }
            if ($debug) {
                print " .. Header: Proto: $hdr_href->{'proto'}, Src: ",
                    "$hdr_href->{'src'}, Src_p: $hdr_href->{'src_p'}, ",
                    "bidir: $hdr_href->{'bidir'}, Dst: $hdr_href->{'dst'}, ",
                    "Dst_p: $hdr_href->{'dst_p'}\n";
            }
            my $opts_href = &parse_rule_options($rule_options, $line_num);
            if ($opts_href) {
                my $rv = &build_ipt_rule($hdr_href, $opts_href);
                if ($rv == 1) {
                    $parsed_ctr++;  ### keep track of successfully parsed rules
                } elsif ($rv == 2) {
                    $logonly_ctr++;
                }
            } else {
                $unsup_ctr++;
                next RULE;
            }
            $abs_num++;;
        }
        printf("%-10s%-10s%-10s%-10s\n", $parsed_ctr, $logonly_ctr,
            $unsup_ctr, $rule_num);
    }
    print "\n";
    if ($abs_num) {  ### we parse at least one rule
        print " .. Generated iptables rules for $abs_num out of ",
            "$sabs_num signatures: ",
            sprintf("%.2f", $abs_num/$sabs_num*100), "%\n";
    } else {
        print " .. No rules parsed.\n";
    }
    return;
}

sub parse_rule_options() {
    my ($rule_options, $line_num) = @_;

    ### tmp hash we will return
    my %opts;

    for my $opt (keys %{$snort_opts{'unsupported'}}) {
        ### see if we match a regex belonging to an supported option
        if ($rule_options =~ /$snort_opts{'unsupported'}{$opt}/) {
            print " ** Unsupported option: \"$opt\" at " .
                "line: $line_num.  Skipping rule.\n" if $verbose;
            return 0;
        }
    }

    for my $type ('filter', 'log_only', 'logprefix') {
        for my $opt (keys %{$snort_opts{$type}}) {
            ### see if we match the option regex
            if ($rule_options =~ /$snort_opts{$type}{$opt}/) {
                $opts{$opt} = $1;
            }
        }
    }

    while ($rule_options =~ /(\w+):\s*.*?;/g) {
        my $option = $1;
        if (! defined $opts{$option}
            && ! defined $snort_opts{'ignore'}{$option}) {
            print "$line_num option: \"$option\" -- $rule_options\n";
        }
    }
    return \%opts;
}

sub parse_rule_hdr() {
    my $rule_hdr = shift;
    my $bidir = 0;
    if ($rule_hdr =~ m|^alert\s+(\S+)\s+\$?(\S+)\s+\$?(\S+)
                        \s+(\S+)\s+\$?(\S+)\s+\$?(\S+)|x) {
        if ($4 eq '<>') {
            $bidir = 1;
            print " ** bidir\n";
        } elsif ($4 eq '<-') {
            return {
                'proto' => $1,
                'src'   => $5,  ### switch src and dst
                'src_p' => $3,
                'bidir' => 0,
                'dst'   => $2,
                'dst_p' => $6,
            };
        }
        return {
            'proto' => $1,
            'src'   => $2,  ### normal src -> dst
            'src_p' => $3,
            'bidir' => $bidir,
            'dst'   => $5,
            'dst_p' => $6,
        };
    } else {
        return 0;
    }
}

sub build_ipt_rule() {
    my ($hdr_href, $opts_href) = @_;

    ### start the rule
    my $rule = $cmds{'iptables'};

    ### determine which chain the rule should be added to (default
    ### to the Snort_<EXTERNAL_INTF> chain).
    my $chain = " -A Snort_${config{'EXTERNAL_INTF'}}";
    if ($config{'NUM_INTERFACES'} > 1) {
        if (defined $config{$hdr_href->{'src'}}
            && defined $intf_net{$config{$hdr_href->{'src'}}}) {
            $chain =
                " -A Snort_${intf_net{$config{$hdr_href->{'src'}}}{'name'}}";
        } elsif (defined $config{$hdr_href->{'dst'}}
            && defined $intf_net{$hdr_href->{'dst'}}) {
            $chain =
                " -A Snort_${intf_net{$config{$hdr_href->{'dst'}}}{'name'}}";
        }
    }

    ### append the chain to the rule
    $rule .= $chain;

    ### append the protocol to the rule
    $rule .= " $iptables_opts{'proto'} $hdr_href->{'proto'}";

    ### append the source
    if (defined $config{$hdr_href->{'src'}}) {
        if (! defined $intf_net{$config{$hdr_href->{'src'}}}) {
            $rule .= " $iptables_opts{'src'} $hdr_href->{'src'}";
        }
    } elsif ($hdr_href->{'src'} ne 'any') {
        $rule .= " $iptables_opts{'src'} $hdr_href->{'src'}";
    }

    ### append the source port
    if (defined $config{$hdr_href->{'src_p'}}) {
        $rule .= " $iptables_opts{'src_p'} $config{$hdr_href->{'src_p'}}";
    } elsif ($hdr_href->{'src_p'} ne 'any') {
        $rule .= " $iptables_opts{'src_p'} $hdr_href->{'src_p'}";
    }

    ### append the destination
    if ($hdr_href->{'dst'} eq 'EXTERNAL_NET') {  ### special case
        $rule .= " $iptables_opts{'dst'} 0.0.0.0/0";
    } elsif (defined $config{$hdr_href->{'dst'}}) {
        if (defined $intf_net{$config{$hdr_href->{'dst'}}}) {
            $rule .= " $iptables_opts{'dst'} " .
                "$intf_net{$config{$hdr_href->{'dst'}}}{'net'}";
        } else {
            $rule .= " $iptables_opts{'dst'} $hdr_href->{'dst'}";
        }
    } elsif ($hdr_href->{'dst'} ne 'any') {
        $rule .= " $iptables_opts{'dst'} $hdr_href->{'dst'}";
    }

    ### append the destination port
    if (defined $config{$hdr_href->{'dst_p'}}) {
        $rule .= " $iptables_opts{'dst_p'} $config{$hdr_href->{'dst_p'}}";
    } elsif ($hdr_href->{'dst_p'} ne 'any') {
        $rule .= " $iptables_opts{'dst_p'} $hdr_href->{'dst_p'}";
    }

    ### handle tcp flags
    if ($hdr_href->{'proto'} eq 'tcp'
        && defined $opts_href->{'flags'}) {
        my $f_str = '';

        $f_str .= 'URG,' if $opts_href->{'flags'} =~ /U/;
        $f_str .= 'ACK,' if $opts_href->{'flags'} =~ /A/;
        $f_str .= 'PSH,' if $opts_href->{'flags'} =~ /P/;
        $f_str .= 'RST,' if $opts_href->{'flags'} =~ /R/;
        $f_str .= 'SYN,' if $opts_href->{'flags'} =~ /S/;
        $f_str .= 'FIN,' if $opts_href->{'flags'} =~ /F/;
        $f_str =~ s/\,$//;

        ### e.g.  --tcp-flags ACK ACK
        $rule .= " $iptables_opts{'flags'} $f_str $f_str";
    }

    ### handle snort content options
    my $content = '';
    if (defined $opts_href->{'uricontent'}) {
        $content = $opts_href->{'uricontent'};
    } elsif (defined $opts_href->{'content'}) {
        $content = $opts_href->{'content'};
    }
    if ($content) {
        if ($content =~ /\|.+\|/) {  ### there is hex data in the content
            $rule .= " $iptables_opts{'content'} --hex-string \"$content\"";
        } else {
            $rule .= " $iptables_opts{'content'} --string \"$content\"";
        }
    }

#    my $log_only_flag = 0;
#    for my $opt (keys %{$snort_opts{'log_only'}) {
#        if (defined $opts_href->{$opt}) {
#            $log_only_flag = 1;

    ### construct the log-prefix
    my $log_prefix = " -j LOG --log-prefix \"";

    ### the ordering was preserved for the logprefix hash
    ### reference, so "msg" will always appear first in the
    ### --log-prefix output, followed by "classtype:", etc.
    my $pref_flag = 0;
    for my $opt (keys %{$snort_opts{'logprefix'}}) {
        if (defined $opts_href->{$opt}) {
            ### make absolutely certain there are no commas in the log
            ### message since we use commas to separate the various fields
            $opts_href->{$opt} =~ s/,//g;
            $log_prefix .= "$opt: $opts_href->{$opt}, ";
            $pref_flag = 1;
        }
    }
    if ($pref_flag) {
        ### all snort signatures should have an option
        ### that should be included within a --log-prefix
        ### string, e.g. "msg" and "sid"
        $log_prefix =~ s/\,\s$//;
        $log_prefix .= "\"";
        $rule .= $log_prefix;
    }

    print $rule, "\n";
    return 1;

}

sub check_type() {
    unless (-e "${rules_dir}/${rules_type}.rules") {
        print " ** \"$rules_type\" is not a valid type.\n",
            "    Choose from the following available signature types:\n";
        opendir D, $rules_dir or die " ** Could not open $rules_dir";
        my @rfiles = readdir D;
        closedir D;
        shift @rfiles; shift @rfiles;
        for my $file (@rfiles) {
            if ($file =~ /^(\S+)\.rules/) {
                print "        $1\n";
            }
        }
        print " ** Exiting.\n";
        exit 1;
    }
    return;
}

sub readconf() {
    open C, "< $fwsnort_conf" or die $!;
    my @lines = <C>;
    close C;
    my $l_ctr = 0;
    for my $line (@lines) {
        $l_ctr++;
        chomp $line;
        next if $line =~ /^\s*#/;
        next unless $line =~ /\S/;
        if ($line =~ /^\s*(\w+)Cmd\s+(\S+);/) {  ### e.g. "iptableCmd"
            $cmds{$1} = $2;
        } elsif ($line =~ /^\s*(\S+)\s+(.*?);/) {
            my $var = $1;
            my $val = $2;
            die " ** $fwsnort_conf: Variable \"$var\" is set to\n",
                "    _CHANGEME_ at line $l_ctr.  Edit $fwsnort_conf.\n"
                if $val eq '_CHANGEME_';
            $config{$var} = $val;
        }
    }
    return;
}

sub validateconf() {
    die " ** The path to ifconfig is not in $fwsnort_conf. Exiting.\n"
        unless defined $cmds{'ifconfig'};
    if (defined $config{'NUM_INTERFACES'}) {
        die " ** $fwsnort_conf: NUM_INTERFACES can be 1, 2, or 3.\n",
            "    Edit $fwsnort_conf.\n" unless
            $config{'NUM_INTERFACES'} =~ /^1$/ or
            $config{'NUM_INTERFACES'} =~ /^2$/ or
            $config{'NUM_INTERFACES'} =~ /^3$/;
    } else {
        die " ** $fwsnort_conf: The NUM_INTERFACES variable is not\n",
            "    defined. Exiting.\n";
    }
    if ($config{'NUM_INTERFACES'} == 3) {
        die " ** $fwsnort_conf: DMZ_INTF is not defined. Exiting.\n"
            unless defined $config{'DMZ_INTF'};
        $intf_type{$config{'DMZ_INTF'}} = 'DMZ_INTF';
        $intf_net{'DMZ_INTF'}{'name'} = $config{'DMZ_INTF'};
        $intf_net{'DMZ_INTF'}{'net'} = &get_intf_net($config{'DMZ_INTF'});
    }
    if ($config{'NUM_INTERFACES'} == 2 || $config{'NUM_INTERFACES'} == 3) {
        die " ** $fwsnort_conf: INTERNAL_INTF is not defined. Exiting.\n"
            unless defined $config{'INTERNAL_INTF'};
        die " ** $fwsnort_conf: DMZ_INTF cannot be defined when ",
            "NUM_INTERFACES is 2. Exiting.\n"
            if defined $config{'DMZ_INTF'};
        $intf_type{$config{'INTERNAL_INTF'}} = 'INTERNAL_INTF';
        $intf_net{'INTERNAL_INTF'}{'name'} = $config{'INTERNAL_INTF'};
        $intf_net{'INTERNAL_INTF'}{'net'} = &get_intf_net($config{'INTERNAL_INTF'});
    } elsif ($config{'NUM_INTERFACES'} == 1) {
        die " ** $fwsnort_conf: INTERNAL_INTF cannot be defined when ",
            "NUM_INTERFACES is 1. Exiting.\n"
            if defined $config{'INTERNAL_INTF'};
        die " ** $fwsnort_conf: DMZ_INTF cannot be defined when ",
            "NUM_INTERFACES is 1. Exiting.\n"
            if defined $config{'DMZ_INTF'};
    }
    die " ** $fwsnort_conf: EXTERNAL_INTF is not defined. Exiting.\n"
        unless defined $config{'EXTERNAL_INTF'};
    $intf_type{$config{'EXTERNAL_INTF'}} = 'EXTERNAL_INTF';
    $intf_net{'EXTERNAL_INTF'}{'name'} = $config{'EXTERNAL_INTF'};
    $intf_net{'EXTERNAL_INTF'}{'net'} = &get_intf_net($config{'EXTERNAL_INTF'});

    ### build ip arrays for the server variables
    &build_ip_arr('HTTP_SERVERS', \@http_servers);
    &build_ip_arr('SMTP_SERVERS', \@smtp_servers);
    &build_ip_arr('DNS_SERVERS', \@dns_servers);
    &build_ip_arr('SQL_SERVERS', \@sql_servers);
    &build_ip_arr('TELNET_SERVERS', \@telnet_servers);
    &build_ip_arr('AIM_SERVERS', \@aim_servers);

    ### build port arrays for the port variables
    &build_port_arr('HTTP_PORTS', \@http_ports);
    &build_port_arr('SHELLCODE_PORTS', \@shellcode_ports);
    &build_port_arr('ORACLE_PORTS', \@oracle_ports);

    ### make sure all necessary iptables options are defined
    ### based on the options in %snort_opts
    for my $snort_opt (keys %{$snort_opts{'filter'}}) {
        die " ** Equivalent iptables filter option not defined\n",
            "    for snort option \"$snort_opt\""
        unless defined $iptables_opts{$snort_opt};
    }

    return;
}

sub build_port_arr() {
    my ($key, $aref) = @_;
    if (defined $config{$key}) {
        @$aref = split /,\s*/, $config{$key};
        for my $port (@$aref) {
            die " ** $fwsnort_conf: $key can only contain a comma\n",
                "    separated list of port numbers.\n"
                unless $port =~ /^\d+$/
                or $port =~ /^\!\d+$/
                or $port =~ /^\d+:\d+$/
                or $port =~ /^!\d+:\d+$/;
        }
        $conf_supported_vars{$key} = '';
    }
    return;
}

sub build_ip_arr() {
    my ($key, $aref) = @_;
    if (defined $config{$key}) {
        my $intf_flag = 0;
        for my $loc (keys %intf_net) {
            if ($config{$key} eq $loc) {
                ### the server variable is tied to an interface
                $intf_flag = 1;
            }
        }
        unless ($intf_flag) {
            @$aref = split /,\s*/, $config{$key};
            for my $ip (@$aref) {
                die " ** $fwsnort_conf: $key can only contain a comma\n",
                    "    separated list of ip addresses.\n"
                    unless $ip =~ /^(?:\d{1,3}\.){3}\d{1,3}$/
                    or $ip =~ m|^(?:\d{1,3}\.){3}\d{1,3}/\d+$|;
            }
        }
        $conf_supported_vars{$key} = '';
    }
    return;
}

sub get_intf_net() {
    my $intf = shift;
    my @if_lines = `$cmds{'ifconfig'} $intf`;
    for my $line (@if_lines) {
        if ($line =~ /^\s+inet\s+addr:(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})
            \s+Bcast:\S+\s+\s+Mask:(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/ix) {
            my ($net, $cidr) = ipv4_network("$1/$2");
            return "${net}/${cidr}";
        }
    }
    die " ** Could not get ip and netmask for interface $intf.  Is the ",
        "    interface up?\n";
}

sub dump_conf() {
    print " .. Interfaces:\n";
    for my $loc (keys %intf_net) {
        print "    Type: $loc, Name: $intf_net{$loc}{'name'}, ",
            "Net: $intf_net{$loc}{'net'}\n";
    }
    print " .. HTTP_SERVERS: ";
    if (defined $config{'HTTP_SERVERS'}) {
        if (@http_servers) {
            print @http_servers, "\n";
        } else {
            print $intf_type{$config{'HTTP_SERVERS'}}, "\n";
        }
    } else {
        print "Not Defined\n";
    }
    print " .. SMTP_SERVERS: ";
    if (defined $config{'SMTP_SERVERS'}) {
        if (@smtp_servers) {
            print @smtp_servers, "\n";
        } else {
            print $intf_type{$config{'SMTP_SERVERS'}}, "\n";
        }
    } else {
        print "Not Defined\n";
    }
    print " .. DNS_SERVERS: ";
    if (defined $config{'DNS_SERVERS'}) {
        if (@dns_servers) {
            print @dns_servers, "\n";
        } else {
            print $intf_type{$config{'DNS_SERVERS'}}, "\n";
        }
    } else {
        print "Not Defined\n";
    }
    print " .. SQL_SERVERS: ";
    if (defined $config{'SQL_SERVERS'}) {
        if (@sql_servers) {
            print @sql_servers, "\n";
        } else {
            print $intf_type{$config{'SQL_SERVERS'}}, "\n";
        }
    } else {
        print "Not Defined\n";
    }
    print " .. TELNET_SERVERS: ";
    if (defined $config{'TELNET_SERVERS'}) {
        if (@telnet_servers) {
            print @telnet_servers, "\n";
        } else {
            print $intf_type{$config{'TELNET_SERVERS'}}, "\n";
        }
    } else {
        print "Not Defined\n";
    }
    print " .. AIM_SERVERS: ";
    if (@aim_servers) {
        print @aim_servers, "\n";
    } else {
        print "Not Defined\n";
    }
    print " .. HTTP_PORTS: ";
    if (@http_ports) {
        print @http_ports, "\n";
    } else {
        print "Not Defined\n";
    }
    print " .. SHELLCODE_PORTS: ";
    if (@shellcode_ports) {
        print @shellcode_ports, "\n";
    } else {
        print "Not Defined\n";
    }
    print " .. ORACLE_PORTS: ";
    if (@oracle_ports) {
        print @oracle_ports, "\n";
    } else {
        print "Not Defined\n";
    }
    exit 0;
}

sub setup() {

    ### turn off buffering
    $| = 1;

    ### these two directories must already exist for
    ### things to work
    die " ** No fwsnort directory: $fwsnort_dir"
        unless -d $fwsnort_dir;
    die " ** No snort rules directory: $rules_dir"
        unless -d $rules_dir;

    ### these directories can be created a runtime
    unless (-d $logdir) {
        mkdir $logdir, 0500 or die $!;
    }
    unless (-d $scripts_dir) {
        mkdir $scripts_dir, 0500 or die $!;
    }
    unless (-d $archive_dir) {
        mkdir $archive_dir, 0500 or die $!;
    }

    ### archive old stuff
#    &archive();
    return;
}

sub chk_commands() {
    for my $cmd (keys %cmds) {
        die " ** $cmd is not located at $cmds{$cmd}"
            unless -e $cmds{$cmd};
        die " ** $cmd is not executable at $cmds{$cmd}"
            unless -x $cmds{$cmd};
    }
    return;
}

#sub archive() {
#    my $file = shift;
#    my ($filename) = ($file =~ m|.*/(.*)|);
#    my $targetbase = "${CONF_ARCHIVE}/${filename}.old";
#    for (my $i = 4; $i > 1; $i--) {  ### keep five copies of the old config files
#        my $oldfile = $targetbase . $i;
#        my $newfile = $targetbase . ($i+1);
#        if (-e $oldfile) {
#            move $oldfile, $newfile;
#        }
#    }
#    if (-e $targetbase) {
#        my $newfile = $targetbase . '2';
#        move $targetbase, $newfile;
#    }
#    &logr(" .. Archiving $file -> $targetbase\n");
#    copy $file, $targetbase;   ### move $file into the archive directory
#    return;
#}

sub logr() {
    my $msg = shift;
    if ($logfile) {
        open LOG, ">> $logfile" or die " ** Could not open $logfile " .
            "$!";
        print LOG $msg;
        close LOG;
    } else {
        print STDOUT $msg;
    }
    return;
}

sub usage() {
    my $exit = shift;
    print <<_USAGE_;

fwsnort usage:
    --fw-apply
    --fw-log
    --fw-drop
    --fw-reject
    -s, --stdout
    -h, --help
_USAGE_
    exit $exit;
}
