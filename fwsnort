#!/usr/bin/perl -w
#
#######################################################################
#
# File: fwsnort
#
# Purpose: To translate snort rules into equivalent iptables rules.
#
# Author: Michael B. Rash
#
# License: GPL
#
#######################################################################
#
# $Id$
#

use Getopt::Long;
use strict;

#======================== config ========================
my $fwsnort_dir = '/etc/fwsnort';
my $rules_dir   = "${fwsnort_dir}/snort_rules";
my $fwrules     = "${fwsnort_dir}/fw_ruleset.sh";

### system binaries
my $shCmd       = '/bin/sh';
my $iptablesCmd = '/sbin/iptables';
#====================== end config ======================

### version number
my $version = '0.1';

### establish some default behavior
my $fw_apply   = 0;
my $fw_log     = 0;
my $fw_drop    = 0;
my $fw_reject  = 0;
my $help       = 0;
my $stdout     = 0;
my $debug      = 0;
my $verbose    = 0;
my $rules_type = '';
my $logfile    = '';

my %snort_sigs;

my %cmds = (
    'iptables' => $iptablesCmd,
    'sh'       => $shCmd
);

&usage(1) unless (GetOptions(
    'fw-apply'  => \$fw_apply,    ### apply the generated ruleset
    'fw-log'    => \$fw_log,
    'fw-drop'   => \$fw_drop,
    'fw-reject' => \$fw_reject,
    'type=s'    => \$rules_type,  ### process this type of snort rules
    'logfile=s' => \$logfile,
    'stdout'    => \$stdout,      ### print the fw ruleset on STDOUT
    'verbose'   => \$verbose,
    'debug'     => \$debug,
    'help'      => \$help
));

&usage(0) if $help;

### make sure some things exist, etc.
&setup();

### make sure the specified <type>.rules file exists
&check_type() if $rules_type;

### parse snort rules (signatures)
&parse_snort_rules();

exit 0;
### write the equivalent iptables ruleset out to disk
&write_iptables();

exit 0;
#===================== end main ======================
sub parse_snort_rules() {
    opendir D, $rules_dir or die " ** Could not open $rules_dir";
    my @rfiles = readdir D;
    closedir D;
    shift @rfiles; shift @rfiles;

    for my $rfile (@rfiles) {
        next unless $rfile =~ /\.rules$/;
        if ($rules_type) {
            next unless $rfile =~ /${rules_type}\.rules$/;
        }
        my ($type) = ($rfile =~ /(\w+)\.rules/);
        print " ==================================================\n";
        print " .. Parsing: $rfile\n";
        open R, "< ${rules_dir}/${rfile}" or die " ** Could not " .
            "open ${rules_type}/${rfile}";
        my @lines = <R>;
        close R;
        my $line_num   = 0;
        my $rule_num   = 0;
        my $parsed_ctr = 0;
        RULE: for my $line (@lines) {
            $line_num++;
            next unless $line =~ /^alert/;
            $rule_num++;  ### keep track of the abs num of rules
            my $rule_hdr;
            my $rule_options;
            if ($line =~ m|^(.*)\s+\((.*)\)|) {
                $rule_hdr     = $1;
                $rule_options = $2;
            } else {  ### don't know what type of snort rule it is
                next RULE;
            }
            my ($proto, $src, $src_p, $bidir, $dst, $dst_p)
                = &parse_rule_hdr($rule_hdr);
            unless ($proto) {
                print " ** Unrecognized rule header: \"$rule_hdr\" at " .
                    "line: $line_num.  Skipping rule.\n";
                next RULE;
            }
            if ($debug) {
                print " .. Header: $proto, $src, $src_p, " .
                    "$bidir, $dst, $dst_p\n";
            }
            my ($msg, $flags, $content, $ref, $sid, $rev, $classtype)
                = &parse_rule_options($rule_options, $line_num);
            unless ($msg) {
                next RULE;
            }
            $parsed_ctr++;  ### keep track of successfully parsed rules
        }
        print " .. Successfully parsed $parsed_ctr out of $rule_num rules.\n";
        print "\n";
    }
    return;
}

sub parse_rule_options() {
    my ($rule_options, $line_num) = @_;
    ### Unsupported options:
    ###   rev: snort rule revision number
    ###   depth: sets the maximum search depth for a pattern match attempt
    ###   offset: sets the offset to begin attempting a pattern match
    ###   dsize: test the packet's payload size against a value
    my $msg       = '';
    my $flags     = '';
    my $content   = '';
    my $ref       = '';
    my $sid       = '';
    my $rev       = '';
    my $classtype = '';
    my $itype     = '';
    my $ttl       = '';
    if ($rule_options =~ /depth:\s*\d+;/) {
        print " ** Unsupported option: \"depth\" at " .
            "line: $line_num.  Skipping rule.\n";
        return 0,0,0,0,0,0,0;
    }
    if ($rule_options =~ /offset:\s*\d+;/) {
        print " ** Unsupported option: \"offset\" at " .
            "line: $line_num.  Skipping rule.\n";
        return 0,0,0,0,0,0,0;
    }
    if ($rule_options =~ /dsize:\s*\S+;/) {
        print " ** Unsupported option: \"dsize\" at " .
            "line: $line_num.  Skipping rule.\n";
        return 0,0,0,0,0,0,0;
    }
    if ($rule_options =~ /icmp_id:\s*\d+;/) {
        print " ** Unsupported option: \"icmp_id\" at " .
            "line: $line_num.  Skipping rule.\n";
        return 0,0,0,0,0,0,0;
    }
    if ($rule_options =~ /icmp_seq:\s*\d+;/) {
        print " ** Unsupported option: \"icmp_seq\" at " .
            "line: $line_num.  Skipping rule.\n";
        return 0,0,0,0,0,0,0;
    }
    if ($rule_options =~ /seq:\s*\d+;/) {
        print " ** Unsupported option: \"seq\" at " .
            "line: $line_num.  Skipping rule.\n";
        return 0,0,0,0,0,0,0;
    }
    if ($rule_options =~ /ack:\s*\d+;/) {
        print " ** Unsupported option: \"ack\" at " .
            "line: $line_num.  Skipping rule.\n";
        return 0,0,0,0,0,0,0;
    }
    if ($rule_options =~ /fragbits:\s*\S+;/) {
        print " ** Unsupported option: \"fragbits\" at " .
            "line: $line_num.  Skipping rule.\n";
        return 0,0,0,0,0,0,0;
    }
    if ($rule_options =~ /icode:\s*\d+;/) {
        print " ** Unsupported option: \"icode\" at " .
            "line: $line_num.  Skipping rule.\n";
        return 0,0,0,0,0,0,0;
    }

    if ($rule_options =~ /msg:\s*\"(.*?)\";/) {
        $msg = $1;
    }
    if ($rule_options =~ /content:\s*\"(.*?)\";/) {
        $content = $1;
    }
    if ($rule_options =~ /flags:\s*(.*?);/) {
        $flags = $1;
    }
    if ($rule_options =~ /reference:\s*(.*?);/) {
        $ref = $1;
    }
    if ($rule_options =~ /sid:\s*(\d+);/) {
        $sid = $1;
    }
    if ($rule_options =~ /rev:\s*(\d+);/) {
        $rev = $1;
    }
    if ($rule_options =~ /classtype:\s*(.*?);/) {
        $classtype = $1;
    }
    while ($rule_options =~ /(\w+):\s*.*?;/g) {
        my $option = $1;
        if ($option ne 'msg' && $option ne 'flags' &&
            $option ne 'reference' && $option ne 'sid' &&
            $option ne 'rev' && $option ne 'classtype' &&
            $option ne 'content' && $option ne 'itype' &&
            $option ne 'ttl') {
            print "$line_num option: $option -- $rule_options\n";
        }
    }
    return $msg, $flags, $content, $ref, $sid, $rev, $classtype;
}

sub parse_rule_hdr() {
    my $rule_hdr = shift;
    my $tmpd;
    if ($rule_hdr =~ m|^alert\s+(\S+)\s+(\S+)\s+(\S+)
                        \s+(\S+)\s+(\S+)\s+(\S+)|x) {
        if ($4 eq '<>') {
            return $1,$2,$3,1,$5,$6;
        } elsif ($4 eq '<-') {
            return $1,$5,$3,0,$2,$6; ### switch src and dst
        }
        return $1,$2,$3,0,$5,$6;  ### normal src -> dst
    } else {
        return 0,0,0,0,0,0;
    }
}

sub check_type() {
    unless (-e "${rules_dir}/${rules_type}.rules") {
        print " ** \"$rules_type\" is not a valid type.\n",
            "    Choose from the following available signature types:\n";
        opendir D, $rules_dir or die " ** Could not open $rules_dir";
        my @rfiles = readdir D;
        closedir D;
        shift @rfiles; shift @rfiles;
        for my $file (@rfiles) {
            if ($file =~ /^(\S+)\.rules/) {
                print "        $1\n";
            }
        }
        print " ** Exiting.\n";
        exit 1;
    }
    return;
}

sub setup() {
    die " ** No fwsnort directory: $fwsnort_dir"
        unless -d $fwsnort_dir;
    die " ** No snort rules directory: $rules_dir"
        unless -d $rules_dir;

    ### make sure the command are where they are supposed to be
    &chk_commands();
    return;
}

sub chk_commands() {
    for my $cmd (keys %cmds) {
        die " ** $cmd is not located at $cmds{$cmd}"
            unless -e $cmds{$cmd};
        die " ** $cmd is not executable at $cmds{$cmd}"
            unless -x $cmds{$cmd};
    }
    return;
}

sub logr() {
    my $msg = shift;
    if ($logfile) {
        open LOG, ">> $logfile" or die " ** Could not open $logfile " .
            "$!";
        print LOG $msg;
        close LOG;
    } else {
        print STDOUT $msg;
    }
    return;
}

sub usage() {
    my $exit = shift;
    print <<_USAGE_;

fwsnort usage:
    --fw-apply
    --fw-log
    --fw-drop
    --fw-reject
    -s, --stdout
    -h, --help
_USAGE_
    exit $exit;
}
