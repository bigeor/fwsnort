#!/usr/bin/perl -w
#
#######################################################################
#
# File: fwsnort
#
# Purpose: To translate snort rules into equivalent iptables rules.
#
# Author: Michael B. Rash
#
# License: GPL
#
#######################################################################
#
# $Id$
#

use Data::Dumper;
use Getopt::Long;
use strict;

#======================== config ========================
my $fwsnort_dir = '/etc/fwsnort';
my $rules_dir   = "${fwsnort_dir}/snort_rules";
my $fwrules     = "${fwsnort_dir}/fw_ruleset.sh";

### system binaries
my $shCmd       = '/bin/sh';
my $iptablesCmd = '/sbin/iptables';
#====================== end config ======================

### version number
my $version = '0.1';

### snort options that should be put into iptables
### ruleset, but only in log messages with --log-prefix
my %sopt_logprefix = (
    'msg'       => 'msg:\s*\"(.*?)\";',
    'reference' => '[\s;]reference:\s*(.*?);',
    'sid'       => '[\s;]sid:\s*(\d+);',
    'rev'       => '[\s;]rev:\s*(\d+);',
    'classtype' => '[\s;]classtype:\s*(.*?);'
);

### snort options that we can directly filter on
### in iptables rulesets (snort options are separate
### from the snort "header" which include protocol,
### source, destination, etc.)
my %sopt_filter = (
    'content' => '[\s;]content:\s*\"(.*?)\";',
    'flags'   => '[\s;]flags:\s*(.*?);',
    'itype'   => '[\s;]itype:\s*(\d+);',
    'ttl'     => '[\s;]ttl:\s*(\d+);'
);

### snort options that cannot be included directly
### within iptables filter statements (yet :)
my %sopt_nofilter = (
    'offset'       => '[\s;]offset:\s*\d+;',
    'depth'        => '[\s;]depth:\s*\d+;',
    'dsize'        => '[\s;]dsize:\s*\S+;',
    'seq'          => '[\s;]seq:\s*\d+;',
    'ack'          => '[\s;]ack:\s*\d+;',
    'fragbits'     => '[\s;]fragbits:\s*\S+;',
    'uricontent'   => '[\s;]uricontent:\s*\".*?\";',
    'content-list' => '[\s;]content\-list:\s*\".*?\";',
    'ipopts'       => '[\s;]ipopts:\s*.*?;',
    'rpc'          => '[\s;]rpc:\s*\S+;',
);

### snort options which are logged within iptables
### logging statements (so we can detect these values
### but just not filter them directly)
my %sopt_log = (
    'id'       => '[\s;]id:\s*(\d+);',
    'seq'      => '[\s;]seq:\s*(\d+);',
    'tos'      => '[\s;]tos:\s*(\d+);',
    'icmp_seq' => '[\s;]icmp_seq:\s*(\d+);',
    'icmp_id'  => '[\s;]icmp_id:\s*(\d+);',
    'icode'    => '[\s;]icode:\s*(\d+);',
);

### establish some default behavior
my $fw_apply   = 0;
my $fw_log     = 0;
my $fw_drop    = 0;
my $fw_reject  = 0;
my $help       = 0;
my $stdout     = 0;
my $debug      = 0;
my $verbose    = 0;
my $rules_type = '';
my $logfile    = '';

my %snort_sigs;

my %cmds = (
    'iptables' => $iptablesCmd,
    'sh'       => $shCmd
);

&usage(1) unless (GetOptions(
    'fw-apply'  => \$fw_apply,    ### apply the generated ruleset
    'fw-log'    => \$fw_log,
    'fw-drop'   => \$fw_drop,
    'fw-reject' => \$fw_reject,
    'type=s'    => \$rules_type,  ### process this type of snort rules
    'logfile=s' => \$logfile,
    'stdout'    => \$stdout,      ### print the fw ruleset on STDOUT
    'verbose'   => \$verbose,
    'debug'     => \$debug,
    'help'      => \$help
));

&usage(0) if $help;

### make sure some things exist, etc.
&setup();

### make sure the specified <type>.rules file exists
&check_type() if $rules_type;

### parse snort rules (signatures)
&parse_snort_rules();

exit 0;
### write the equivalent iptables ruleset out to disk
&write_iptables();

exit 0;
#===================== end main ======================
sub parse_snort_rules() {
    opendir D, $rules_dir or die " ** Could not open $rules_dir";
    my @rfiles = readdir D;
    closedir D;
    shift @rfiles; shift @rfiles;

    my $abs_num = 0;
    my $sabs_num = 0;
    for my $rfile (@rfiles) {
        next unless $rfile =~ /\.rules$/;
        if ($rules_type) {
            next unless $rfile =~ /${rules_type}\.rules$/;
        }
        my ($type) = ($rfile =~ /(\w+)\.rules/);
        print " ==================================================\n";
        print " .. Parsing: $rfile\n";
        open R, "< ${rules_dir}/${rfile}" or die " ** Could not " .
            "open ${rules_type}/${rfile}";
        my @lines = <R>;
        close R;
        my $line_num   = 0;
        my $rule_num   = 0;
        my $parsed_ctr = 0;
        RULE: for my $line (@lines) {
            $line_num++;
            next unless $line =~ /^alert/;
            $rule_num++;  ### keep track of the abs num of rules
            my $rule_hdr;
            my $rule_options;
            $sabs_num++;
            if ($line =~ m|^(.*)\s+\((.*)\)|) {
                $rule_hdr     = $1;
                $rule_options = $2;
            } else {  ### don't know what type of snort rule it is
                next RULE;
            }
            my $hdr_href = &parse_rule_hdr($rule_hdr);
            unless ($hdr_href) {
                print " ** Unrecognized rule header: \"$rule_hdr\" at ",
                    "line: $line_num.  Skipping rule.\n";
                next RULE;
            }
            if ($debug) {
                print " .. Header: $hdr_href->{'proto'}, $hdr_href->{'src'} ",
                    "    $hdr_href->{'src_p'}, bidir: $hdr_href->{'bidir'} ",
                    "$hdr_href->{'dst'}, $hdr_href->{'dst_p'}\n";
            }
            my ($opt_filter_href, $opt_logprefix_href)
                = &parse_rule_options($rule_options, $line_num);
            unless ($opt_filter_href) {
                next RULE;
            }
            $parsed_ctr++;  ### keep track of successfully parsed rules
            $abs_num++;;
        }
        print " .. Successfully parsed $parsed_ctr out of $rule_num rules.\n";
        print "\n";
    }
    print " ==========\n";
    print " .. Totals: Parsed $abs_num out of $sabs_num: " .
        sprintf("%.2f", $abs_num/$sabs_num*100) . "%\n";
    return;
}

sub parse_rule_options() {
    my ($rule_options, $line_num) = @_;

    my %opt_logprefix;
    my %opt_filter;
    my %opt_log;

    for my $option (keys %sopt_nofilter) {
        my $regex = $sopt_nofilter{$option};
        if ($rule_options =~ /$regex/) {
            print " ** Unsupported option: \"$option\" at " .
                "line: $line_num.  Skipping rule.\n" if $verbose;
            return 0;
        }
    }

    for my $option (keys %sopt_log) {
        my $regex = $sopt_log{$option};
        if ($rule_options =~ /$regex/) {
            $opt_log{$option} = $1;
        }
    }
    for my $option (keys %sopt_logprefix) {
        my $regex = $sopt_logprefix{$option};
        if ($rule_options =~ /$regex/) {
            $opt_logprefix{$option} = $1;
        }
    }
    for my $option (keys %sopt_filter) {
        my $regex = $sopt_filter{$option};
        if ($rule_options =~ /$regex/) {
            $opt_filter{$option} = $1;
        }
    }

    while ($rule_options =~ /(\w+):\s*.*?;/g) {
        my $option = $1;
        if (! defined $sopt_filter{$option} &&
            ! defined $sopt_logprefix{$option} &&
            ! defined $sopt_log{$option}) {
            print "$line_num option: $option -- $rule_options\n";
        }
    }
    return \%opt_filter, \%opt_logprefix;
}

sub parse_rule_hdr() {
    my $rule_hdr = shift;
    my $bidir = 0;
    if ($rule_hdr =~ m|^alert\s+(\S+)\s+(\S+)\s+(\S+)
                        \s+(\S+)\s+(\S+)\s+(\S+)|x) {
        if ($4 eq '<>') {
            $bidir = 1;
        } elsif ($4 eq '<-') {
            return {
                'proto' => $1,
                'src'   => $5,  ### switch src and dst
                'src_p' => $3,
                'bidir' => 0,
                'dst'   => $2,
                'dst_p' => $6,
            };
        }
        return {
            'proto' => $1,
            'src'   => $2,  ### normal src -> dst
            'src_p' => $3,
            'bidir' => $bidir,
            'dst'   => $5,
            'dst_p' => $6,
        };
    } else {
        return 0;
    }
}

sub check_type() {
    unless (-e "${rules_dir}/${rules_type}.rules") {
        print " ** \"$rules_type\" is not a valid type.\n",
            "    Choose from the following available signature types:\n";
        opendir D, $rules_dir or die " ** Could not open $rules_dir";
        my @rfiles = readdir D;
        closedir D;
        shift @rfiles; shift @rfiles;
        for my $file (@rfiles) {
            if ($file =~ /^(\S+)\.rules/) {
                print "        $1\n";
            }
        }
        print " ** Exiting.\n";
        exit 1;
    }
    return;
}

sub setup() {
    die " ** No fwsnort directory: $fwsnort_dir"
        unless -d $fwsnort_dir;
    die " ** No snort rules directory: $rules_dir"
        unless -d $rules_dir;

    ### make sure the command are where they are supposed to be
    &chk_commands();
    return;
}

sub chk_commands() {
    for my $cmd (keys %cmds) {
        die " ** $cmd is not located at $cmds{$cmd}"
            unless -e $cmds{$cmd};
        die " ** $cmd is not executable at $cmds{$cmd}"
            unless -x $cmds{$cmd};
    }
    return;
}

sub logr() {
    my $msg = shift;
    if ($logfile) {
        open LOG, ">> $logfile" or die " ** Could not open $logfile " .
            "$!";
        print LOG $msg;
        close LOG;
    } else {
        print STDOUT $msg;
    }
    return;
}

sub usage() {
    my $exit = shift;
    print <<_USAGE_;

fwsnort usage:
    --fw-apply
    --fw-log
    --fw-drop
    --fw-reject
    -s, --stdout
    -h, --help
_USAGE_
    exit $exit;
}
