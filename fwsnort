#!/usr/bin/perl -w
#
#######################################################################
#
# File: fwsnort
#
# Purpose: To translate snort rules into equivalent iptables rules.
#
# Author: Michael B. Rash <mbr@cipherdyne.com>
#
# Copyright (C) 2003 Michael B. Rash (mbr@cipherdyne.com)
#
# License (GNU Public License):
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
#    USA
#
#######################################################################
#
# $Id$
#

use Net::IPv4Addr qw(:all);
use File::Copy;
use Sys::Hostname;
use Getopt::Long;
use strict;

#======================== config ========================
my $fwsnort_dir = '/etc/fwsnort';
my $rules_dir   = "${fwsnort_dir}/snort_rules";
my $logdir      = "${fwsnort_dir}/log";
my $scripts_dir = "${fwsnort_dir}/fwscripts";
my $archive_dir = "${fwsnort_dir}/archive";

### config file
my $fwsnort_conf = "${fwsnort_dir}/fwsnort.conf";

### log and error files
my $logfile    = "${logdir}/fwsnort.log";
my $parse_errs = "${logdir}/parse_errs.log";

### iptables script
my $fwscript = "${scripts_dir}/fw_ruleset.sh";
#====================== end config ======================

### version number
my $version = '0.1';

### snort options that should be put into iptables
### ruleset, but only in log messages with --log-prefix
my %sopt_logprefix = (
    'msg'       => 'msg:\s*\"(.*?)\";',
    'reference' => '[\s;]reference:\s*(.*?);',
    'sid'       => '[\s;]sid:\s*(\d+);',
    'rev'       => '[\s;]rev:\s*(\d+);',
    'classtype' => '[\s;]classtype:\s*(.*?);'
);

### snort options that we can directly filter on
### in iptables rulesets (snort options are separate
### from the snort "header" which include protocol,
### source, destination, etc.)
my %sopt_filter = (
    'uricontent'   => '[\s;]uricontent:\s*\".*?\";',
    'content' => '[\s;]content:\s*\"(.*?)\";',
    'flags'   => '[\s;]flags:\s*(.*?);',
    'itype'   => '[\s;]itype:\s*(\d+);',
    'ttl'     => '[\s;]ttl:\s*(\d+);',
    'tos'     => '[\s;]tos:\s*(\d+);'
);

### snort options that cannot be included directly
### within iptables filter statements (yet :)
my %sopt_nofilter = (
    'offset'       => '[\s;]offset:\s*\d+;',
    'depth'        => '[\s;]depth:\s*\d+;',
    'dsize'        => '[\s;]dsize:\s*\S+;',
    'seq'          => '[\s;]seq:\s*\d+;',
    'ack'          => '[\s;]ack:\s*\d+;',
    'fragbits'     => '[\s;]fragbits:\s*\S+;',
    'content-list' => '[\s;]content\-list:\s*\".*?\";',
    'ipopts'       => '[\s;]ipopts:\s*.*?;',
    'rpc'          => '[\s;]rpc:\s*\S+;',
);

### snort options which are logged within iptables
### logging statements (so we can detect these values
### but just not filter them directly)
my %sopt_log = (
    'id'       => '[\s;]id:\s*(\d+);',
    'seq'      => '[\s;]seq:\s*(\d+);',
    'icmp_seq' => '[\s;]icmp_seq:\s*(\d+);',
    'icmp_id'  => '[\s;]icmp_id:\s*(\d+);',
    'icode'    => '[\s;]icode:\s*(\d+);',
);

### establish some default behavior
my $fw_apply   = 0;
my $fw_log     = 0;
my $fw_drop    = 0;
my $fw_reject  = 0;
my $help       = 0;
my $stdout     = 0;
my $debug      = 0;
my $verbose    = 0;
my $rules_type = '';
my $ext_net    = '';
my $int_net    = '';

my %snort_sigs;
my $snort_sid;

### config and commands hashes (constructed by readconf())
my %config;
my %cmds;

&usage(1) unless (GetOptions(
    'fw-apply'    => \$fw_apply,    # apply the generated ruleset
    'fw-log'      => \$fw_log,
    'fw-drop'     => \$fw_drop,
    'fw-reject'   => \$fw_reject,
    'snort-sid=i' => \$snort_sid,   # Parse only this particular snort rule
    'type=s'      => \$rules_type,  # process this type of snort rule
#    'ext-net'     => \$ext_int,     # manually specify the external network
#    'home-net'    => \$home_int,    # manually specify the internal interface
#    'ext-int'     => \$ext_int,     # manually specify the external interface
#    'int-int'     => \$int_int,     # manually specify the internal interface
    'logfile=s'   => \$logfile,
    'stdout'      => \$stdout,      # print the fw ruleset on STDOUT
    'verbose'     => \$verbose,
    'debug'       => \$debug,
    'help'        => \$help
));

&usage(0) if $help;

### make sure some directories exist, etc.
&setup();

### read in configuration info from the config file
&readconf();

### make sure the commands are where the
### config file says they are
&chk_commands();

### make sure the specified <type>.rules file exists
### if --type was used
&check_type() if $rules_type;

### get the internal and external networks if they were
### not specified with --

### parse snort rules (signatures)
print "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=",
    "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n",
    sprintf("%-30s%-10s%-10s%-10s%-10s", '    File', 'Filter',
        'Log-only', 'Failed', 'Total'), "\n\n";
&parse_snort_rules();
print "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=",
    "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n";

exit 0;
### write the equivalent iptables ruleset out to disk
&write_iptables();

exit 0;
#===================== end main ======================
sub parse_snort_rules() {
    opendir D, $rules_dir or die " ** Could not open $rules_dir";
    my @rfiles = readdir D;
    closedir D;
    shift @rfiles; shift @rfiles;

    my $abs_num = 0;
    my $sabs_num = 0;
    FILE: for my $rfile (@rfiles) {
        next FILE unless $rfile =~ /\.rules$/;
        if ($rules_type) {
            next FILE unless $rfile =~ /${rules_type}\.rules$/;
        }
        my ($type) = ($rfile =~ /(\w+)\.rules/);
        printf("%-30s", " .. $rfile");
        open R, "< ${rules_dir}/${rfile}" or die " ** Could not " .
            "open: ${rules_type}/${rfile}";
        my @lines = <R>;
        close R;
        my $line_num    = 0;
        my $rule_num    = 0;
        my $parsed_ctr  = 0;
        my $logonly_ctr = 0;
        my $unsup_ctr   = 0;
        RULE: for my $line (@lines) {
            $line_num++;
            next RULE unless $line =~ /^alert/;
            $rule_num++;  ### keep track of the abs num of rules
            my $rule_hdr;
            my $rule_options;
            $sabs_num++;
            if ($line =~ m|^(.*)\s+\((.*)\)|) {
                $rule_hdr     = $1;
                $rule_options = $2;
            } else {  ### don't know what type of snort rule it is
                next RULE;
            }
            my $hdr_href = &parse_rule_hdr($rule_hdr);
            unless ($hdr_href) {
                print " ** Unrecognized rule header: \"$rule_hdr\" at ",
                    "line: $line_num.  Skipping rule.\n";
                $unsup_ctr++;
                next RULE;
            }
            if ($debug) {
                print " .. Header: $hdr_href->{'proto'}, $hdr_href->{'src'} ",
                    "    $hdr_href->{'src_p'}, bidir: $hdr_href->{'bidir'} ",
                    "$hdr_href->{'dst'}, $hdr_href->{'dst_p'}\n";
            }
            my ($ipttype, $opt_filter_href, $opt_logprefix_href)
                = &parse_rule_options($rule_options, $line_num);
            if ($ipttype == 1) {  ### we can filter
#                &add_ipt_filter_rule($hdr_href, $opt_filter_href);
                $parsed_ctr++;  ### keep track of successfully parsed rules
            } elsif ($ipttype == 2) {
                &add_ipt_log_rule($hdr_href, $opt_logprefix_href);
                $logonly_ctr++;
            } else {
                $unsup_ctr++;
                next RULE;
            }
            $abs_num++;;
        }
        printf("%-10s%-10s%-10s%-10s\n", $parsed_ctr, $logonly_ctr,
            $unsup_ctr, $rule_num);
    }
    print "\n";
    if ($abs_num) {  ### we parse at least one rule
        print " .. Generated iptables rules for $abs_num out of ",
            "$sabs_num signatures: ",
            sprintf("%.2f", $abs_num/$sabs_num*100), "%\n";
    } else {
        print " .. No rules parsed.\n";
    }
    return;
}

sub parse_rule_options() {
    my ($rule_options, $line_num) = @_;

    my %opt_logprefix;
    my %opt_filter;
    my %opt_log;
    my $status = 1;   ### 1 => can filter with iptables, 2 => iptables logs

    for my $option (keys %sopt_nofilter) {
        my $regex = $sopt_nofilter{$option};
        if ($rule_options =~ /$regex/) {
            print " ** Unsupported option: \"$option\" at " .
                "line: $line_num.  Skipping rule.\n" if $verbose;
            return 0;
        }
    }

    ### if we match one of these options we cannot write filter
    ### rules directly but we can still detect the signature in
    ### iptables log messages.
    for my $option (keys %sopt_log) {
        my $regex = $sopt_log{$option};
        if ($rule_options =~ /$regex/) {
            $opt_log{$option} = $1;
            $status = 2;
        }
    }

    ### match snort options such as "msg" and "sid" that should
    ### go in --log-prefix.
    for my $option (keys %sopt_logprefix) {
        my $regex = $sopt_logprefix{$option};
        if ($rule_options =~ /$regex/) {
            $opt_logprefix{$option} = $1;
        }
    }

    ### match snort options such as "content" and "ttl" that we
    ### can write filter rules for directly.
    for my $option (keys %sopt_filter) {
        my $regex = $sopt_filter{$option};
        if ($rule_options =~ /$regex/) {
            $opt_filter{$option} = $1;
        }
    }

    while ($rule_options =~ /(\w+):\s*.*?;/g) {
        my $option = $1;
        if (! defined $sopt_filter{$option} &&
            ! defined $sopt_logprefix{$option} &&
            ! defined $sopt_log{$option}) {
            print "$line_num option: \"$option\" -- $rule_options\n";
        }
    }
    return $status, \%opt_filter, \%opt_logprefix;
}

sub parse_rule_hdr() {
    my $rule_hdr = shift;
    my $bidir = 0;
    if ($rule_hdr =~ m|^alert\s+(\S+)\s+(\S+)\s+(\S+)
                        \s+(\S+)\s+(\S+)\s+(\S+)|x) {
        if ($4 eq '<>') {
            $bidir = 1;
        } elsif ($4 eq '<-') {
            return {
                'proto' => $1,
                'src'   => $5,  ### switch src and dst
                'src_p' => $3,
                'bidir' => 0,
                'dst'   => $2,
                'dst_p' => $6,
            };
        }
        return {
            'proto' => $1,
            'src'   => $2,  ### normal src -> dst
            'src_p' => $3,
            'bidir' => $bidir,
            'dst'   => $5,
            'dst_p' => $6,
        };
    } else {
        return 0;
    }
}

sub add_ipt_filter_rule() {
    my ($hdr_href, $opt_filter_href) = @_;
    my $src_port = '';
    my $dst_port = '';
    unless ($hdr_href->{'src_p'} eq 'any') {
        $src_port = "--sport $hdr_href->{'src_p'}";
    }
    unless ($hdr_href->{'dst_p'} eq 'any') {
        $src_port = "--dport $hdr_href->{'dst_p'}";
    }
    ### iptables  -A INPUT -p tcp --sport 3999 -m string
    ###     --hex-string "fsdf" -j LOG
#    if ($hdr_href->{'src'} eq '$EXTERNAL_NET' &&
#        $hdr_href->{'dst'} eq '$HOME_NET') {
        print "$cmds{'iptables'} -A SnortRules -p $hdr_href->{'proto'} ",
            "$src_port $dst_port -i eth0 -j LOG\n";
#    }
    return;
}

sub add_ipt_log_rule() {
    my ($hdr_href, $opt_logprefix_href) = @_;
    return;
}

sub check_type() {
    unless (-e "${rules_dir}/${rules_type}.rules") {
        print " ** \"$rules_type\" is not a valid type.\n",
            "    Choose from the following available signature types:\n";
        opendir D, $rules_dir or die " ** Could not open $rules_dir";
        my @rfiles = readdir D;
        closedir D;
        shift @rfiles; shift @rfiles;
        for my $file (@rfiles) {
            if ($file =~ /^(\S+)\.rules/) {
                print "        $1\n";
            }
        }
        print " ** Exiting.\n";
        exit 1;
    }
    return;
}

sub readconf() {
    open C, "< $fwsnort_conf" or die $!;
    my @lines = <C>;
    close C;
    for my $line (@lines) {
        chomp $line;
        next if $line =~ /^\s*#/;
        next unless $line =~ /\S/;
        if ($line =~ /^\s*(\w+)Cmd\s+(\S+);/) {  ### e.g. "iptableCmd"
            $cmds{$1} = $2;
        } elsif ($line =~ /^\s*(\S+)\s+(\S+);/) {
            $config{$1} = $2;
        }
    }
    return;
}

sub setup() {

    ### turn off buffering
    $| = 1;

    ### these two directories must already exist for
    ### things to work
    die " ** No fwsnort directory: $fwsnort_dir"
        unless -d $fwsnort_dir;
    die " ** No snort rules directory: $rules_dir"
        unless -d $rules_dir;

    ### these directories can be created a runtime
    unless (-d $logdir) {
        mkdir $logdir, 0500 or die $!;
    }
    unless (-d $scripts_dir) {
        mkdir $scripts_dir, 0500 or die $!;
    }
    unless (-d $archive_dir) {
        mkdir $archive_dir, 0500 or die $!;
    }

    ### archive old stuff
#    &archive();
    return;
}

sub chk_commands() {
    for my $cmd (keys %cmds) {
        die " ** $cmd is not located at $cmds{$cmd}"
            unless -e $cmds{$cmd};
        die " ** $cmd is not executable at $cmds{$cmd}"
            unless -x $cmds{$cmd};
    }
    return;
}

#sub archive() {
#    my $file = shift;
#    my ($filename) = ($file =~ m|.*/(.*)|);
#    my $targetbase = "${CONF_ARCHIVE}/${filename}.old";
#    for (my $i = 4; $i > 1; $i--) {  ### keep five copies of the old config files
#        my $oldfile = $targetbase . $i;
#        my $newfile = $targetbase . ($i+1);
#        if (-e $oldfile) {
#            move $oldfile, $newfile;
#        }
#    }
#    if (-e $targetbase) {
#        my $newfile = $targetbase . '2';
#        move $targetbase, $newfile;
#    }
#    &logr(" .. Archiving $file -> $targetbase\n");
#    copy $file, $targetbase;   ### move $file into the archive directory
#    return;
#}

sub logr() {
    my $msg = shift;
    if ($logfile) {
        open LOG, ">> $logfile" or die " ** Could not open $logfile " .
            "$!";
        print LOG $msg;
        close LOG;
    } else {
        print STDOUT $msg;
    }
    return;
}

sub usage() {
    my $exit = shift;
    print <<_USAGE_;

fwsnort usage:
    --fw-apply
    --fw-log
    --fw-drop
    --fw-reject
    -s, --stdout
    -h, --help
_USAGE_
    exit $exit;
}
